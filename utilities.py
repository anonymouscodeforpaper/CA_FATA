# -*- coding: utf-8 -*-
"""utilities.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pnZaKJbOqRwvijELe8KbUxG9y1B0z3iN
"""

from sklearn.preprocessing import LabelEncoder
import torch
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
loss_func = torch.nn.MSELoss()
from sklearn.metrics import f1_score, roc_auc_score,accuracy_score
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
def binary_predictions(true_ratings, predicted_ratings,args):
    assert len(true_ratings) == len(predicted_ratings)
    binary_true_ratings = []
    binary_predicted_ratings = []
    if args.name == 'Frappe':
        threhold = 0.903090
    elif args.name == 'Yelp':
        threhold = 3
    for i in range(len(true_ratings)):
        if true_ratings[i] >= threhold:
            binary_true_ratings.append(1)
        else:
            binary_true_ratings.append(0)

        if predicted_ratings[i] >= threhold:
            binary_predicted_ratings.append(1)
        else:
            binary_predicted_ratings.append(0)

    return precision_score(binary_true_ratings, binary_predicted_ratings), recall_score(binary_true_ratings, binary_predicted_ratings), f1_score(binary_true_ratings, binary_predicted_ratings)


def arg_accuracy_int(ratings, predictions):
    ratings = ratings.cpu().detach().numpy()
    predictions = predictions.cpu().detach().numpy()
    total_nr = len(ratings)
    total_pred = 0
    for i in range(total_nr):
        (true_rating, pred_rating) = ratings[i], predictions[i]
        if round(pred_rating) >= int(true_rating)-1 and round(pred_rating) <= int(true_rating)+1:
            total_pred += 1

    return float(total_pred)/total_nr


def round_of_rating(number):
    return round(number * 2) / 2

# def RMSE(data, model,meta_app_knowledge):
#     model.eval()
#     contexts_index = data.iloc[:, 3:].values
#     contexts_index = torch.tensor(contexts_index).to(DEVICE)
#     item = data['item'].values
#     entities_index = meta_app_knowledge.loc[item].iloc[:, 1:].values
#     entities_index = torch.tensor(entities_index).to(DEVICE)

#     rating = torch.FloatTensor(data['cnt'].values).to(DEVICE)
#     user = torch.LongTensor(data['user'].values).to(DEVICE)
#     item = torch.LongTensor(data['item'].values).to(DEVICE)
#     rating = (rating + 1) * 2 + 1
#     rating = rating * 4.458668059764898 / 5
#     # Predict and calculate loss
#     prediction = model(user, contexts_index, entities_index)
#     prediction = (prediction + 1) * 2 + 1
#     prediction = prediction * 4.458668059764898 / 5
#     rating = rating.cpu().detach()
#     prediction = prediction.cpu().detach()
#     rmse = loss_func(prediction, rating)
#     mae = torch.nn.L1Loss()(prediction, rating)
#     p,r,f = binary_predictions(rating, prediction)
#     accuracy = arg_accuracy_int(rating,prediction)
#     return  torch.sqrt(rmse), mae,p,r,f,accuracy

def RMSE(data, model,meta_app_knowledge,args):
    model.eval()
    contexts_index = data.iloc[:, 3:].values
    contexts_index = torch.tensor(contexts_index).to(DEVICE)
    item = data['item'].values
    entities_index = meta_app_knowledge.loc[item].iloc[:, 1:].values
    entities_index = torch.tensor(entities_index).to(DEVICE)

    rating = torch.FloatTensor(data['cnt'].values).to(DEVICE)
    user = torch.LongTensor(data['user'].values).to(DEVICE)
    item = torch.LongTensor(data['item'].values).to(DEVICE)
    rating = (rating + 1) * 2 + 1
    if args.name == 'Frappe':
        rating = rating * 4.458668059764898 / 5
    # Predict and calculate loss
    prediction = model(user, contexts_index, entities_index)
    prediction = (prediction + 1) * 2 + 1
    if args.name == 'Frappe':
        prediction = prediction * 4.458668059764898 / 5
    rating = rating.cpu().detach()
    prediction = prediction.cpu().detach()
    rmse = loss_func(prediction, rating)
    mae = torch.nn.L1Loss()(prediction, rating)
    p,r,f = binary_predictions(rating, prediction,args)
    accuracy = arg_accuracy_int(rating,prediction)
    return  torch.sqrt(rmse), mae,p,r,f,accuracy

